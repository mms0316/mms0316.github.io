<!--
This webpage uses Prismarine NBT (https://github.com/PrismarineJS/prismarine-nbt)
and code adapted from litemapy (https://github.com/SmylerMC/litemapy/)

Since Litematica and litemapy are GPLv3.0, here it is:

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<!DOCTYPE html>
<html lang="en">
<head>
<title>MapartCraft Schematic Checker</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta property="og:title" content="MapartCraft Schematic Checker" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://mms0316.github.io/mapartchecker.html" />
<meta property="og:image" content="https://mms0316.github.io/mapartchecker.png" /> <!--TODO remake png-->
<meta property="og:description" content="Validates schematic's placement origin, fixes slabs and blocks under." />

<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin="anonymous" referrerpolicy="no-referrer" />

<script src="./pnbt.js"></script>
<style>
    .hidden {
        display: none;
    }
    .outline-success {
        outline-color: green;
    }
    .outline-error {
        outline-color: red;
    }
    #dropzone {
        position: fixed;
        top: 0;
        left: 0; 
        z-index: 999;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        transition: visibility 175ms, opacity 175ms;
    }
</style>
</head>
<body>

<div id="dropzone" style="visibility:hidden; opacity:0"></div>

<header class="w3-container w3-dark-grey">
<h2>MapartCraft Schematic Checker</h2>
</header>
<form class="w3-container">
    <div class="w3-panel">
        <h3>Placement origin</h3>

        <div class="w3-section">
            <label for="x">X</label>
            <input type="number" id="x" step="1" class="w3-input w3-border">
            <div id="x_validation" class="hidden"></div>
        </div>

        <div class="w3-section">
            <label for="y">Y</label>
            <input type="number" id="y" step="1" class="w3-input w3-border" disabled="disabled">
            <div id="y_validation" class="hidden"></div>
        </div>

        <div class="w3-section">
            <label for="z">Z</label>
            <input type="number" id="z" step="1" class="w3-input w3-border">
            <div id="z_validation" class="hidden"></div>
        </div>
    </div>
    
    <div class="w3-panel">
        <h3>Upload schematic</h3>

        <input type="file" id="schem" class="w3-input">

        <div id="schem_dimensions" class="w3-container hidden">
            Dimensions: <span id="schem_dimension_x"></span> x <span id="schem_dimension_y"></span> x <span id="schem_dimension_z"></span>
        </div>
        <div id="schem_error" class="w3-border-red w3-pale-red hidden"></div>
    </div>
</form>

<div id="progress" class="w3-panel w3-center hidden">
    <i id="spinner" class="fa fa-spinner" style="font-size: 48px"></i>
</div>

<div id="results_container" class="w3-panel hidden">
    <div id="results" class="w3-responsive"></div>
    <button id="save_button"><i class="fa fa-download"></i> Download as .schem</button>
</div>

<script type="module">
    import { parseMinecraftSchematic, xyzToKey, convertToSchem} from './js/schematics.js';

    const progress = document.getElementById("progress");
    const spinner = document.getElementById("spinner");

    const dropzone = document.getElementById("dropzone");
    var lastTarget = null; //cache for drag and drop events

    const results_container = document.getElementById("results_container");
    const results = document.getElementById("results");
    const save_button = document.getElementById("save_button");

    const x = document.getElementById("x");
    const x_validation = document.getElementById('x_validation');

    const y = document.getElementById("y");
    const y_validation = document.getElementById('y_validation');
    const MAX_Y = 320;
    const MAX_HEIGHT = 384;

    const z = document.getElementById("z");
    const z_validation = document.getElementById('z_validation');

    // X and Z validations

    function showSuccess(element, validation) {
        element.classList.remove("w3-border-red", "outline-error");
        element.classList.add("w3-border-teal", "outline-success");
        validation.classList.add("hidden");

        validation.classList.add("w3-border-teal", "w3-pale-green");
        validation.classList.remove("w3-border-red", "w3-pale-red");
    }

    function showError(element, validation, errorHTML) {
        element.classList.add("w3-border-red", "outline-error");
        element.classList.remove("w3-border-teal", "outline-success");

        validation.classList.remove("hidden");

        validation.classList.remove("w3-border-teal", "w3-pale-green");
        validation.classList.add("w3-border-red", "w3-pale-red");
        validation.innerHTML = errorHTML;
    }

    function validate(element, expectedRemainder, validation) {
        const val = Math.floor(element.value) || 0;

        var remainder = val % 128;
        if (remainder < 0)
            remainder += 128;

        if (remainder == expectedRemainder) {
            showSuccess(element, validation);
        } else {
            const lower = Math.floor((val - 64) / 128);
            const upper = Math.floor((val + 64) / 128);

            showError(element, validation,
                      'Closest values are <b>' + (lower * 128 + expectedRemainder) + '</b> and <b>' + (upper * 128 + expectedRemainder) + '</b>.');
        }
    }

    x.addEventListener("input", function () {
        validate(x, 64, x_validation);
    });

    z.addEventListener("input", function () {
        validate(z, 63, z_validation);
    });


    // Schematic validation
    const schem = document.getElementById("schem");
    const schem_dimensions = document.getElementById("schem_dimensions");
    const schem_error = document.getElementById("schem_error");

    const schem_dimension_x = document.getElementById("schem_dimension_x");
    const schem_dimension_y = document.getElementById("schem_dimension_y");
    const schem_dimension_z = document.getElementById("schem_dimension_z");

    const nbt = require('prismarine-nbt')
    const { Buffer } = require('buffer');

    function resetSchematicOutput() {
        progress.classList.add("hidden");
        spinner.classList.remove("w3-spin");

        schem_dimensions.classList.add("hidden");

        schem_dimension_x.innerHTML = '';
        schem_dimension_y.innerHTML = '';
        schem_dimension_z.innerHTML = '';

        schem_error.classList.add("hidden");
        y.setAttribute("disabled", "");

        results_container.classList.add("hidden");

        results.innerHTML = '';
    }

    function showSchematicError(errorHTML) {
        schem_error.classList.remove("hidden");
        schem_error.innerHTML = errorHTML;

        results_container.classList.add("hidden");
        results.innerHTML = '';
    }

    document.addEventListener("dragover", event => {
        event.preventDefault(); // prevent default to allow drop
    });

    document.addEventListener("dragenter", function(e) {
        lastTarget = e.target; // cache the last target here
        // unhide our dropzone overlay
        dropzone.style.visibility = "";
        dropzone.style.opacity = 1;
    });

    document.addEventListener("dragleave", function(e) {
        // this is the magic part. when leaving the window,
        // e.target happens to be exactly what we want: what we cached
        // at the start, the dropzone we dragged into.
        // so..if dragleave target matches our cache, we hide the dropzone.
        // `e.target === document` is a workaround for Firefox 57
        if (e.target === lastTarget || e.target === document) {
            dropzone.style.visibility = "hidden";
            dropzone.style.opacity = 0;
        }
    });

    document.addEventListener("drop", function(e) {
        e.preventDefault(); // prevent dragged file from being opened

        dropzone.style.visibility = "hidden";
        dropzone.style.opacity = 0;

        schem.value = "";

        if (e.dataTransfer.items) {
            // Use DataTransferItemList interface to access the file(s)
            for (let i = 0; i < e.dataTransfer.items.length; i++) {
                // If dropped items aren't files, reject them
                if (e.dataTransfer.items[i].kind === 'file') {
                    const file = e.dataTransfer.items[i].getAsFile();
                    resetSchematicOutput();
                    handleSchematic(file);
                    break;
                }
            }
        }
        else {
            // Use DataTransfer interface to access the file(s)
            if (e.dataTransfer.files.length > 0) {
                resetSchematicOutput();
                handleSchematic(e.dataTransfer.files[0]);
            }
        }
    });

    schem.addEventListener("change", function (event) {
        const fileList = this.files;

        if (fileList.length > 0) {
            resetSchematicOutput();
            handleSchematic(fileList[0]);
        }
    }, false);

    let schematic;
    function handleSchematic(file) {
        const reader = new FileReader();
        reader.readAsArrayBuffer(file);
        reader.onload = function(evt) {
            nbt.parse(Buffer.from(evt.target.result)).then(nbt => {
                const consolidate = true;
                schematic = parseMinecraftSchematic(nbt, file.name, consolidate);

                if (schematic) {
                    let changed = false;
                    fixBlocksUnder();
                    fixFarmableMaterials();
                    changed ||= fixSlabs();
                    updateSaveButton(changed, file.name);

                    schem_dimension_x.innerHTML = schematic.xsize;
                    schem_dimension_y.innerHTML = schematic.ysize;
                    schem_dimension_z.innerHTML = schematic.zsize;

                    if (parseInt(schematic.ysize) >= MAX_HEIGHT) {
                        showSchematicError("Schematic's height is above " + MAX_HEIGHT);
                    }

                    schem_dimensions.classList.remove("hidden");
                    y.removeAttribute("disabled");
                    y.dispatchEvent(new Event('input', {bubbles:true}));
                }
                else {
                    resetSchematicOutput();
                    showSchematicError("Schematic format not recognized");
                    schematic = null;
                }
            }).catch(function() {
                resetSchematicOutput();
                showSchematicError("Schematic format not recognized");
                schematic = null;
            });
        };
    }

    y.addEventListener("input", function () {
        const val = Math.floor(this.value) || 0;
        const height = parseInt(schem_dimension_y.innerHTML);

        if (val + height < MAX_Y) {
            showSuccess(y, y_validation);
        }
        else if (height >= MAX_HEIGHT) {
            showError(y, y_validation,
                      "Schematic's height is above " + MAX_HEIGHT);
        }
        else {
            showError(y, y_validation,
                      "Maximum value should be <b>" + (MAX_Y - height - 1) + "</b>.");
        }
    });

    function fixBlocksUnder() {
    }

    function fixFarmableMaterials() {
    }

    function fixSlabs() {
        const changedMaterials = new Set();

        for (const [key, val] of schematic.blocks.entries()) {
            const [material, properties] = val;

            if (material.endsWith("_slab") && properties !== "[type=top]") {
                schematic.blocks.get(key)[1] = "[type=top]";

                if (!changedMaterials.has(material)) {
                    results.innerHTML += 'Changed to top slab: ' + material + '<br>';
                    changedMaterials.add(material);
                }
            }
        }

        if (changedMaterials.size > 0) {
            let section = document.createElement("section");
            section.classList.add("w3-panel");
            results.appendChild(section);

            results_container.classList.remove("hidden");
        }

        return (changedMaterials.size > 0);
    }

    function updateSaveButton(changed, filename) {
        if (changed) {
            save_button.addEventListener("click", function(event) {
                const buffer = convertToSchem(schematic);

                if (!filename.endsWith(".schem"))
                    filename += ".schem";

                download(filename, buffer);
            });
        }
    }

    function download(filename, uint8array) {
        const element = document.createElement("a");
        const blob = new Blob([uint8array], {type: "application/octet-stream"});

        element.setAttribute('href', window.URL.createObjectURL(blob));
        element.setAttribute('download', filename);

        element.style.display = 'none';
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
    }
</script>
</body>
</html>
