<!--
This webpage uses Prismarine NBT (https://github.com/PrismarineJS/prismarine-nbt)
-->
<!DOCTYPE html>
<html lang="en">
<head>
<title>Litematica x MapartCraft Coordinate Checker</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta property="og:title" content="Litematica x MapartCraft Coordinate Checker" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://mms0316.github.io/mapartchecker.html" />
<meta property="og:image" content="https://mms0316.github.io/mapartchecker.png" />
<meta property="og:description" content="Validates if X, Y and Z coordinates are good as a schematic's placement origin." />

<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<script src="./pnbt.js"></script>
<style>
    .hidden {
        display: none;
    }
    .outline-success {
        outline-color: green;
    }
    .outline-error {
        outline-color: red;
    }
    #dropzone {
        position: fixed;
        top: 0;
        left: 0; 
        z-index: 999;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        transition: visibility 175ms, opacity 175ms;
    }
</style>
</head>
<body>

<div id="dropzone" style="visibility:hidden; opacity:0"></div>

<header class="w3-container w3-dark-grey">
<h2>Litematica x MapartCraft Coordinate Checker</h2>
</header>
<form class="w3-container">
    <div class="w3-panel">
        <h3>Placement origin</h3>

        <div class="w3-section">
            <label for="x">X</label>
            <input type="number" id="x" step="1" class="w3-input w3-border">
            <div id="x_validation" class="hidden"></div>
        </div>

        <div class="w3-section">
            <label for="y">Y</label>
            <input type="number" id="y" step="1" class="w3-input w3-border" disabled="disabled">
            <div id="y_validation" class="hidden"></div>
        </div>

        <div class="w3-section">
            <label for="z">Z</label>
            <input type="number" id="z" step="1" class="w3-input w3-border">
            <div id="z_validation" class="hidden"></div>
        </div>
    </div>
    
    <div class="w3-panel">
        <h3>Upload schematic for Y validation</h3>

        <input type="file" id="schem" class="w3-input">

        <div id="schem_dimensions" class="w3-container hidden">
            Dimensions: <span id="schem_dimension_x"></span> x <span id="schem_dimension_y"></span> x <span id="schem_dimension_z"></span>
        </div>
        <div id="schem_error" class="w3-border-red w3-pale-red hidden"></div>
    </div>
</form>

<script>
    const dropzone = document.getElementById("dropzone");

    const x = document.getElementById("x");
    const x_validation = document.getElementById('x_validation');

    const y = document.getElementById("y");
    const y_validation = document.getElementById('y_validation');
    const MAX_Y = 320;
    const MAX_HEIGHT = 384;

    const z = document.getElementById("z");
    const z_validation = document.getElementById('z_validation');

    // X and Z validations

    function showSuccess(element, validation) {
        element.classList.remove("w3-border-red", "outline-error");
        element.classList.add("w3-border-teal", "outline-success");
        validation.classList.add("hidden");

        validation.classList.add("w3-border-teal", "w3-pale-green");
        validation.classList.remove("w3-border-red", "w3-pale-red");
    }

    function showError(element, validation, errorHTML) {
        element.classList.add("w3-border-red", "outline-error");
        element.classList.remove("w3-border-teal", "outline-success");

        validation.classList.remove("hidden");

        validation.classList.remove("w3-border-teal", "w3-pale-green");
        validation.classList.add("w3-border-red", "w3-pale-red");
        validation.innerHTML = errorHTML;
    }

    function validate(element, expectedRemainder, validation) {
        const val = Math.floor(element.value) || 0;

        var remainder = val % 128;
        if (remainder < 0)
            remainder += 128;

        if (remainder == expectedRemainder) {
            showSuccess(element, validation);
        } else {
            const lower = Math.floor((val - 64) / 128);
            const upper = Math.floor((val + 64) / 128);

            showError(element, validation,
                      'Closest values are <b>' + (lower * 128 + expectedRemainder) + '</b> and <b>' + (upper * 128 + expectedRemainder) + '</b>.');
        }
    }

    x.addEventListener("input", function () {
        validate(x, 64, x_validation);
    });

    z.addEventListener("input", function () {
        validate(z, 63, z_validation);
    });


    // Schematic validation
    const schem = document.getElementById("schem");
    const schem_dimensions = document.getElementById("schem_dimensions");
    const schem_error = document.getElementById("schem_error");

    const schem_dimension_x = document.getElementById("schem_dimension_x");
    const schem_dimension_y = document.getElementById("schem_dimension_y");
    const schem_dimension_z = document.getElementById("schem_dimension_z");

    const nbt = require('prismarine-nbt')
    const { Buffer } = require('buffer');

    function resetSchematicDimensions() {
        schem_dimensions.classList.add("hidden");

        schem_dimension_x.innerHTML = '';
        schem_dimension_y.innerHTML = '';
        schem_dimension_z.innerHTML = '';

        schem_error.classList.add("hidden");
        y.setAttribute("disabled", "");
    }

    function showSchematicError(errorHTML) {
        schem_error.classList.remove("hidden");
        schem_error.innerHTML = errorHTML;
    }

    document.addEventListener("dragover", event => {
        event.preventDefault(); // prevent default to allow drop
    });

    document.addEventListener("dragenter", function(e) {
        lastTarget = e.target; // cache the last target here
        // unhide our dropzone overlay
        dropzone.style.visibility = "";
        dropzone.style.opacity = 1;
    });

    document.addEventListener("dragleave", function(e) {
        // this is the magic part. when leaving the window,
        // e.target happens to be exactly what we want: what we cached
        // at the start, the dropzone we dragged into.
        // so..if dragleave target matches our cache, we hide the dropzone.
        // `e.target === document` is a workaround for Firefox 57
        if (e.target === lastTarget || e.target === document) {
            dropzone.style.visibility = "hidden";
            dropzone.style.opacity = 0;
        }
    });

    document.addEventListener("drop", function(e) {
        e.preventDefault(); // prevent dragged file from being opened

        dropzone.style.visibility = "hidden";
        dropzone.style.opacity = 0;

        schem.value = "";

        if (e.dataTransfer.items) {
            // Use DataTransferItemList interface to access the file(s)
            for (let i = 0; i < e.dataTransfer.items.length; i++) {
                // If dropped items aren't files, reject them
                if (e.dataTransfer.items[i].kind === 'file') {
                    const file = e.dataTransfer.items[i].getAsFile();
                    handleSchematic(file);
                    break;
                }
            }
        }
        else {
            // Use DataTransfer interface to access the file(s)
            if (e.dataTransfer.files.length > 0) {
                handleSchematic(e.dataTransfer.files[0]);
            }
        }
    });

    schem.addEventListener("change", function (event) {
        const fileList = this.files;

        resetSchematicDimensions();

        if (fileList.length > 0) {
            handleSchematic(fileList[0]);
        }
    }, false);

    function handleSchematic(file) {
        const reader = new FileReader();
        reader.readAsArrayBuffer(file);
        reader.onload = function(evt) {
            nbt.parse(Buffer.from(evt.target.result)).then(nbt => {
                var handled = false;
                // Attempt .nbt
                try {
                    const size = nbt.parsed.value.size.value.value;

                    schem_dimension_x.innerHTML = size[0];
                    schem_dimension_y.innerHTML = size[1];
                    schem_dimension_z.innerHTML = size[2];

                    handled = true;
                } catch { }

                //Attempt .litematic
                if (!handled) {
                    try {
                        const size = nbt.parsed.value.Metadata.value.EnclosingSize.value;

                        schem_dimension_x.innerHTML = size.x.value;
                        schem_dimension_y.innerHTML = size.y.value;
                        schem_dimension_z.innerHTML = size.z.value;

                        handled = true;
                    } catch { }
                }

                if (handled) {
                    if (parseInt(schem_dimension_y.innerHTML) >= MAX_HEIGHT) {
                        showSchematicError("Schematic's height is above " + MAX_HEIGHT);
                    }

                    schem_dimensions.classList.remove("hidden");
                    y.removeAttribute("disabled");
                    y.dispatchEvent(new Event('input', {bubbles:true}));
                }
            }).catch(function() {
                resetSchematicDimensions();
                showSchematicError("Schematic format not recognized");
            });
        };
    }

    y.addEventListener("input", function () {
        const val = Math.floor(this.value) || 0;
        const height = parseInt(schem_dimension_y.innerHTML);

        if (val + height < MAX_Y) {
            showSuccess(y, y_validation);
        }
        else if (height >= MAX_HEIGHT) {
            showError(y, y_validation,
                      "Schematic's height is above " + MAX_HEIGHT);
        }
        else {
            showError(y, y_validation,
                      "Maximum value should be <b>" + (MAX_Y - height - 1) + "</b>.");
        }
    });

</script>
</body>
</html>
